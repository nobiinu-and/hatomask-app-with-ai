# BDDとTDDを使った開発プロセス

このドキュメントは、Specを基にBDD(振る舞い駆動開発)とTDD(テスト駆動開発)を組み合わせた開発手順を定義します。

## 開発の全体フロー

**段階的な開発アプローチ**: 各機能の受け入れ基準(シナリオ)を1つずつ実装し、Green状態を確認してから次に進みます。

### Phase 1: 要件定義とSpec作成
1. ビジネス要件を分析し、機能仕様を明確化する
2. `spec/features/`ディレクトリに機能仕様書(Markdown)を作成する
   - `spec/templates/feature.template.md`をベースに使用する
   - 機能の概要、スコープ、ユースケースを記述する
   - UI/UX要件、技術要件、データモデルを定義する
3. **受け入れ基準をGiven-When-Thenの形式で記述する**
   - Specification by Exampleとして実行可能な形式で書く
   - 正常系シナリオを複数パターン用意する
   - 異常系シナリオ(エラーケース)を含める
   - エッジケースやバリデーションシナリオを追加する
   - パラメータ化テスト(Scenario Outline)が必要な場合は記述する
4. ステークホルダーと仕様をレビュー・合意する

### Phase 2: BDD - E2Eシナリオの作成
4. 機能仕様書の**受け入れ基準セクション**から、実装する順番を決める
5. **最初のシナリオ(通常は正常系の基本パターン)を1つ選ぶ**
6. 選んだシナリオを`e2e/features/`にCucumberのFeatureファイル(.feature)として転記する
   - Specに記述したGiven-When-Thenをそのまま使用する
   - 1つのシナリオから始める(すべてのシナリオを一度に実装しない)
7. Featureファイルをレビューし、仕様との整合性を確認する

### Phase 3: E2Eテストの実装(Red)
8. `e2e/step-definitions/`に、選んだシナリオのステップ定義を作成する
9. Playwrightを使って、各ステップの実装を記述する
10. E2Eテストを実行し、**失敗することを確認する**(Red状態)

### Phase 4: TDD - フロントエンド開発(モックAPI使用)

**シナリオのステップ単位で実装とテストを繰り返す**

11. **現在のシナリオをステップごとに分割する**
    - Given/When/Thenの各ステップを確認
    - 実装する順序を決定(通常はGiven→When→Thenの順)
    
12. **最初のステップを選択し、Red-Green-Refactorサイクルを回す**
    
    a) **モックAPI作成**(必要な場合)
    - MSW(Mock Service Worker)でモックAPIを作成(`src/frontend/src/test/mocks/`)
    - Specに定義されたAPIエンドポイントとレスポンス形式を基にモックを作成
    - 該当ステップで必要なAPIエンドポイントのみ実装
    
    b) **ユニットテスト作成**(Red)
    - フロントエンドのユニットテストを書く(`src/frontend/src/test/`)
    - そのステップに必要なコンポーネント、フック、ユーティリティのテストのみ
    - テストを実行し、**失敗することを確認する**(Red状態)
    
    c) **実装**(Green)
    - 最小限の実装でテストを通す
    - Reactコンポーネント、カスタムフック、API連携などを実装
    - ユニットテストが通ることを確認
    
    d) **E2Eテストで検証**(Green)
    - モックAPIを使用して、該当ステップまでのE2Eテストを実行
    - E2Eテストが通ることを確認
    
    e) **APIデータフォーマット検証**
    - フロントエンドでの使いやすさを確認
    - レスポンスデータの構造が適切か評価
    - 必要に応じてAPIレスポンス形式を改善し、モックとSpecを更新
    
    f) **リファクタリング**(Refactor)
    - コードの品質を向上させる
    - すべてのテストが通ることを確認
    
13. **次のステップに進む**
    - シナリオの次のステップ(Whenステップ、Thenステップなど)を選択
    - ステップ12に戻り、すべてのステップが実装されるまで繰り返す

14. **シナリオ全体の確認**
    - シナリオのすべてのステップが実装された
    - モックAPIを使用して、シナリオ全体のE2Eテストを実行
    - すべてのテスト(ユニット、E2E)が通ることを確認
    - **最終的なAPIデータフォーマットを確定し、Specを更新**

> **実装の歩幅**: 自信がある場合や単純な実装の場合は、複数のステップをまとめて実装してもよい。
> ただし、複雑な機能や不確実性が高い場合は、1ステップずつ確実に実装する。

### Phase 5: TDD - バックエンド開発(リファクタリング)

**Greenを維持したまま、モックAPIをリアルAPIに置き換える**

15. **テストリストの作成**
    - Phase 4で確定したAPI仕様とビジネスロジックを基にテストリストを作成
    - `testlists/`ディレクトリにMarkdown形式で記録
    - テストリストに含める項目:
      - Controller層のテスト(正常系、異常系、バリデーション)
      - UseCase層のテスト(ビジネスロジック、エラーハンドリング)
      - Repository層のテスト(CRUD操作、クエリ)
      - Infrastructure層のテスト(ファイルストレージ、外部API連携など)
      - 統合テスト(層間の連携)
    - テストリストの優先順位付け(重要度・依存関係順)

16. **テストリストから1つずつテストを実装する**
    
    テストリストの各項目に対して、以下のRed-Green-Refactorサイクルを回す:
    
    a) **テストを書く**(Red)
    - テストリストから1つ選んで、そのユニットテストを書く(`src/backend/src/test/`)
    - テストを実行し、**失敗することを確認する**(Red状態)
    - テストリストで該当項目を「🔴 実装中」としてマーク
    
    b) **最小限の実装**(Green)
    - テストを通すための最小限のコードを実装
      - ドメインモデル
      - アプリケーションサービス(UseCase)
      - リポジトリ
      - インフラストラクチャ層
    - テストを実行し、**成功することを確認する**(Green状態)
    - Phase 4で確定したレスポンス形式を正確に実装
    - モックAPIと同じデータ構造を返すように実装
    
    c) **リファクタリング**(Refactor)
    - コードの品質を向上させる
    - 重複を削除、命名を改善、構造を整理
    - すべてのテストが通ることを確認
    - テストリストで該当項目を「✅ 完了」としてマーク
    
    d) **次のテストへ**
    - テストリストから次の項目を選び、ステップa)に戻る
    - すべてのテストが完了するまで繰り返す

17. **テストリストの完了確認**
    - すべてのテスト項目が「✅ 完了」になっていることを確認
    - バックエンドのすべてのユニットテストが通ることを確認
    - テストカバレッジを確認(目標: 80%以上)

### Phase 6: 統合とE2Eテストの確認(Green - リアルAPI使用)
22. **モックAPIを無効化し、リアルバックエンドAPIを使用する**
23. 現在のシナリオのE2Eテストを再実行し、**成功することを確認する**(Green状態)
24. E2Eテストが失敗する場合は、原因を特定し修正する
    - バックエンドのレスポンス形式がモックと一致しているか確認
    - エラーハンドリングが適切か確認
    - データ型、フィールド名、ネストの深さなどを検証
25. すべてのテスト(ユニット、統合、E2E)が通ることを確認する

### Phase 7: 次のシナリオへ進む
26. **Specの受け入れ基準から次のシナリオを選ぶ**
27. 次のシナリオを`e2e/features/`に追加する
28. **Phase 3に戻り、フロントエンド→バックエンドのサイクルを繰り返す**
29. すべてのシナリオが実装されるまで繰り返す

> **重要**: 1つのシナリオをGreen状態にしてから次のシナリオに進むこと。
> 複数のシナリオを同時に実装しないこと。段階的に機能を追加していくことで、
> 問題の早期発見と安定した開発が可能になります。

### Phase 8: コードレビューとリファクタリング
30. すべてのシナリオがGreen状態になったことを確認する
31. コーディング規約に従っているか確認する(`CODING_STANDARDS.md`を参照)
32. Linterを実行し、コード品質をチェックする
33. コードレビューを実施する
34. リファクタリングが必要な箇所を改善する
35. すべてのテスト(ユニット、統合、E2E)が通ることを確認する

### Phase 9: ドキュメント更新とデプロイ
36. README.mdやその他のドキュメントを更新する
37. テストリスト(`testlists/`)を更新する
38. 変更をコミット・プッシュする
39. CI/CDパイプラインでテストが通ることを確認する
40. デプロイを実行する

## 重要な原則

### シナリオ駆動の段階的開発
受け入れ基準に記述された各シナリオを1つずつ実装します:
1. **1シナリオずつ選択**: Specの受け入れ基準から実装するシナリオを1つ選ぶ
2. **E2Eテスト作成**: 選んだシナリオをCucumberのFeatureファイルに追加(Red)
3. **フロントエンド実装(ステップ単位)**: 
   - シナリオのステップ(Given/When/Then)を1つずつ実装
   - 各ステップで: モックAPI作成 → ユニットテスト → 実装 → E2Eテスト → API検証
   - 自信がある場合は複数ステップをまとめて実装してもよい
4. **バックエンド実装**: Greenを維持したまま、モックAPIをリアルAPIに置き換える(Refactor)
5. **Green確認後、次へ**: 1つのシナリオがGreenになってから次のシナリオに進む
6. **全シナリオ完了まで繰り返す**

この段階的なアプローチにより:
- 問題を早期に発見できる
- 各シナリオの実装範囲が明確になる
- ステップ単位の細かい実装で確実に前進できる
- デバッグが容易になる
- フロントエンドとバックエンドを独立して開発できる
- API設計を実装しながら改善できる
- 安定した開発ペースを維持できる
### フロントエンド→バックエンドの実装順序
**なぜフロントエンドを先に実装するのか:**
1. **ユーザー体験の早期検証**: UIとUXを先に確認できる
2. **API設計の改善**: フロントエンド実装を通じて、使いやすいAPI仕様が明確になる
   - モックAPIで実際にデータを扱うことで、レスポンス形式の使いやすさを判断できる
   - 不便なデータ構造や不足しているフィールドを早期に発見できる
   - フロントエンドの実装経験を基にAPI仕様を改善できる
   - バックエンド実装前に最適なデータフォーマットを確定できる
3. **並行開発の準備**: モックAPIがあれば、フロントエンドとバックエンドを並行して開発できる
4. **テストの安定性**: フロントエンドがGreenになってから、バックエンドをリファクタリングとして実装できる

### モックAPI実装時のAPI設計レビューポイント
- レスポンスデータがフロントエンドで扱いやすい形式か
- 不要なデータや冗長なネストがないか
- 日付・時刻のフォーマットは適切か(ISO 8601推奨)
- エラーレスポンスの形式は一貫しているか(RFC 9457準拠)
- ページネーションやフィルタリングのパラメータは直感的か
- null値の扱いが明確か
4. **テストの安定性**: フロントエンドがGreenになってから、バックエンドをリファクタリングとして実装できる

### Red-Green-Refactorサイクル
- **Red**: テストを書き、失敗することを確認する
- **Green**: 最小限の実装でテストを通す
- **Refactor**: コードの品質を向上させる

### テストの優先順位
1. E2Eテスト(Cucumber + Playwright): ユーザーの振る舞いを検証
2. ユニットテスト(JUnit/Vitest): 個々のユニットの動作を検証
3. 統合テスト: コンポーネント間の連携を検証

### ディレクトリ構造
```
spec/features/           # 機能仕様書(人間が読むドキュメント)
e2e/features/           # Cucumberのシナリオ(実行可能な仕様)
e2e/step-definitions/   # ステップ定義の実装
src/backend/src/test/   # バックエンドのテストコード
src/frontend/src/test/  # フロントエンドのテストコード
testlists/              # テスト計画とチェックリスト
```

## 段階的開発の実践例

### 例: 写真アップロード機能の開発

#### イテレーション1: 基本的なJPEGアップロード

**シナリオ:**
```gherkin
Given ユーザーがHatoMaskアプリケーションにアクセスしている
When ユーザーが「写真を選択」ボタンをクリックする
And ユーザーがファイルサイズ5MBのJPEGファイルを選択する
Then アップロードが成功する
And プレビューエリアに選択した画像が表示される
When ユーザーが「ダウンロード」ボタンをクリックする
Then 元の画像がダウンロードされる
```

**Phase 2-3: E2Eテスト作成**
1. このシナリオをFeatureファイルに追加
2. ステップ定義を作成 → **Red状態確認**

**Phase 4: フロントエンド実装(ステップ単位)**

**ステップ1: Given - 初期表示**
- モックAPI不要(静的ページ)
- ユニットテスト作成: `App`コンポーネントのレンダリング
- 実装: 基本レイアウトとボタン配置
- E2Eテスト実行(Givenステップまで) → Green

**ステップ2: When - ファイル選択**
- モックAPI不要(ブラウザAPI使用)
- ユニットテスト作成: ファイル選択イベント処理
- 実装: ファイル入力とバリデーション
- E2Eテスト実行(Whenステップまで) → Green

**ステップ3: And - ファイルアップロード**
- **モックAPI作成**: `POST /api/v1/photos`のモックレスポンス
- ユニットテスト作成: アップロードロジック、状態管理
- 実装: アップロード処理、エラーハンドリング
- E2Eテスト実行(Andステップまで) → Green
- **API検証**: レスポンス形式が使いやすいか確認、必要に応じて修正

**ステップ4: Then - アップロード成功とプレビュー表示**
- **モックAPI追加**: `GET /api/v1/photos/{id}`のモックレスポンス
- ユニットテスト作成: プレビューコンポーネント
- 実装: 画像表示、レスポンシブ対応
- E2Eテスト実行(Thenステップまで) → Green

**ステップ5-6: When/Then - ダウンロード**
- モックAPI使用(既存のGETエンドポイント)
- ユニットテスト作成: ダウンロード処理
- 実装: ダウンロードボタンとロジック
- E2Eテスト実行(シナリオ全体) → **Green状態確認**
- **API仕様確定**: Specを更新

**Phase 5: バックエンド実装(TDD)**

**ステップ1: テストリスト作成**
```markdown
# テストリスト: 写真アップロード機能

### Controller層
- [ ] 🔴 POST /api/v1/photos - 正常系: JPEGファイルで200を返す
- [ ] 🔴 POST /api/v1/photos - 異常系: ファイルサイズ超過で400を返す
- [ ] 🔴 GET /api/v1/photos/{id} - 正常系: 画像バイナリを返す
- [ ] 🔴 GET /api/v1/photos/{id} - 異常系: 存在しないIDで404を返す

### UseCase層
- [ ] 🔴 UploadPhotoUseCase - 正常系: ファイルを保存しPhotoエンティティを返す
- [ ] 🔴 UploadPhotoUseCase - 異常系: サイズ超過で例外をスローする
- [ ] 🔴 GetPhotoUseCase - 正常系: IDから画像データを取得できる
- [ ] 🔴 GetPhotoUseCase - 異常系: 存在しないIDで例外をスローする

### Repository層
- [ ] 🔴 PhotoRepository - 保存: Photoエンティティを保存できる
- [ ] 🔴 PhotoRepository - 取得: IDでPhotoエンティティを取得できる

### Infrastructure層
- [ ] 🔴 FileStorageService - ファイル保存: ローカルにファイルを保存できる
- [ ] 🔴 FileStorageService - ファイル取得: 保存したファイルを取得できる
```

**ステップ2-15: テストリストを1つずつ実装**
- 各項目をRed→Green→Refactorのサイクルで実装
- 完了した項目を「✅」にマーク
- すべての項目が完了するまで繰り返す

**Phase 6: 統合確認**
- モックAPI無効化、リアルAPI使用
- E2Eテスト実行(リアルAPI使用) → **Green状態確認**

#### イテレーション2: PNGファイル対応
1. Specから「PNGファイルのアップロードとダウンロード」シナリオを選択
2. このシナリオをFeatureファイルに追加
3. E2Eテスト作成 → **Red状態確認**
4. **モックAPI更新**: PNG対応のレスポンス追加
5. **フロントエンド実装**: ファイル形式の検証ロジック追加
6. E2Eテスト実行(モックAPI使用) → **Green状態確認**
7. **バックエンド実装**: PNG形式のファイル処理追加
## コマンド例

### フロントエンド開発フェーズ

#### モックサーバーの起動
```bash
cd src/frontend
npm run dev  # モックAPIが自動的に有効化される
```

#### フロントエンドのユニットテスト実行
```bash
cd src/frontend
npm test
```

#### E2Eテスト実行(モックAPI使用)
```bash
cd e2e
# モックサーバーを起動した状態で
npm test -- --name "JPEGファイルのアップロード"
```

### バックエンド開発フェーズ

#### バックエンドのユニットテスト実行
```bash
cd src/backend
mvn test
```

#### バックエンドサーバーの起動
```bash
cd src/backend
mvn spring-boot:run
```

#### E2Eテスト実行(リアルAPI使用)
```bash
cd e2e
# バックエンドサーバーを起動した状態で
# モックAPIを無効化するには環境変数を設定
USE_MOCK_API=false npm test -- --name "JPEGファイルのアップロード"
```

### すべてのテストの実行
```bash
# すべてのシナリオ、すべてのテスト
./scripts/run-all-tests.sh
```

### バックエンドテストの実行
```bash
cd src/backend
mvn test
```

### フロントエンドテストの実行
```bash
cd src/frontend
npm test
```

### すべてのテストの実行
```bash
./scripts/run-all-tests.sh
```

## Given-When-Thenの書き方ガイド

### 基本構造
```gherkin
Given [前提条件・初期状態]
When [ユーザーのアクション]
Then [期待される結果]
```

### 書き方のポイント

#### Given (前提条件)
- テストの初期状態を記述する
- 必要なデータやシステムの状態を明確にする
- 例:
  - `Given ユーザーがHatoMaskアプリケーションにアクセスしている`
  - `Given データベースに5件の写真が保存されている`
  - `Given ユーザーが認証済みである`

#### When (アクション)
- ユーザーが実行する具体的なアクションを記述する
- 1つのシナリオで複数のWhenを使う場合は`And`でつなげる
- 例:
  - `When ユーザーが「写真を選択」ボタンをクリックする`
  - `And ユーザーがファイルサイズ5MBのJPEGファイルを選択する`

#### Then (期待結果)
- アクション後の期待される結果を記述する
- UIの状態、データの変化、メッセージ表示などを明確にする
- 複数の期待結果は`And`でつなげる
- 例:
  - `Then アップロードが成功する`
  - `And プレビューエリアに選択した画像が表示される`
  - `And ダウンロードボタンが有効化される`

### シナリオの種類

#### 1. 正常系シナリオ (Happy Path)
基本的な成功パターンを記述
```gherkin
Scenario: 写真のアップロードとダウンロード
  Given ユーザーがアプリケーションにアクセスしている
  When ユーザーがJPEGファイルをアップロードする
  Then プレビューに画像が表示される
```

#### 2. 異常系シナリオ (Error Cases)
エラーケースとバリデーションを記述
```gherkin
Scenario: ファイルサイズ超過エラー
  Given ユーザーがアプリケーションにアクセスしている
  When ユーザーがファイルサイズ11MBのファイルを選択する
  Then エラーメッセージが表示される
  And 画像はアップロードされない
```

#### 3. パラメータ化テスト (Scenario Outline)
複数のデータパターンで同じロジックをテスト
```gherkin
Scenario Outline: 異なるファイル形式のアップロード
  Given ユーザーがアプリケーションにアクセスしている
  When ユーザーが<ファイル形式>のファイルをアップロードする
  Then アップロードが<結果>する

  Examples:
    | ファイル形式 | 結果   |
    | JPEG        | 成功   |
    | PNG         | 成功   |
    | GIF         | 失敗   |
```

### ベストプラクティス

1. **具体的で測定可能に**: 曖昧な表現を避け、検証可能な結果を記述する
2. **ユーザー視点で書く**: 技術的な実装詳細ではなく、ユーザーの行動と体験に焦点を当てる
3. **1シナリオ1テスト**: 1つのシナリオで1つの振る舞いをテストする
4. **独立性を保つ**: シナリオは他のシナリオに依存しない形で書く
5. **実装詳細を避ける**: APIエンドポイントやクラス名ではなく、振る舞いを記述する

### アンチパターン

❌ **避けるべき書き方**
```gherkin
Given システムが起動している
When APIを呼び出す
Then 200が返る
```

✅ **推奨される書き方**
```gherkin
Given ユーザーがログインしている
When ユーザーがプロフィールを更新する
Then 更新成功メッセージが表示される
And 新しいプロフィール情報が保存される
```

## テストリストの書き方

バックエンド開発を始める前に、実装すべきテストの一覧を作成します。

### テストリストの構造

```markdown
# テストリスト: [機能名]

## 概要
[このテストリストの目的と対象範囲]

## テスト項目

### Controller層
- [ ] 🔴 [エンドポイント名] - 正常系: 有効なリクエストで200を返す
- [ ] 🔴 [エンドポイント名] - 異常系: 無効なパラメータで400を返す
- [ ] 🔴 [エンドポイント名] - 異常系: リソースが存在しない場合404を返す
- [ ] 🔴 [エンドポイント名] - バリデーション: ファイルサイズ超過で400を返す

### UseCase層
- [ ] 🔴 [UseCaseクラス名] - 正常系: [期待される動作]
- [ ] 🔴 [UseCaseクラス名] - 異常系: [エラーケース]
- [ ] 🔴 [UseCaseクラス名] - ビジネスロジック: [特定のルール]

### Repository層
- [ ] 🔴 [Repositoryクラス名] - 保存: エンティティを正しく保存できる
- [ ] 🔴 [Repositoryクラス名] - 取得: IDでエンティティを取得できる
- [ ] 🔴 [Repositoryクラス名] - 更新: エンティティを更新できる
- [ ] 🔴 [Repositoryクラス名] - 削除: エンティティを削除できる

### Infrastructure層
- [ ] 🔴 [Serviceクラス名] - ファイル保存: ローカルにファイルを保存できる
- [ ] 🔴 [Serviceクラス名] - ファイル取得: 保存したファイルを取得できる

### 統合テスト
- [ ] 🔴 E2Eフロー: [アップロードから取得までの一連の流れ]
```

### 記号の意味
- `[ ] 🔴` : 未実装(Red)
- `[ ] 🟡` : 実装中
- `[x] ✅` : 完了(Green)

### テストリストの優先順位
1. **ドメイン層から順に実装**: ドメインロジック → UseCase → Repository → Controller
2. **正常系を先に実装**: まず基本的な動作を確認してから、異常系やエッジケースへ
3. **依存関係を考慮**: 他のテストが依存するテストを先に実装

## 参考ドキュメント
- `spec/templates/feature.template.md`: 機能仕様のテンプレート
- `testlists/README.md`: テストリストの詳細
- `CODING_STANDARDS.md`: コーディング規約
- `DEVELOPMENT.md`: 開発環境のセットアップ
- `TEST_STRUCTURE.md`: テスト構造の詳細
- `LINTER.md`: Linterの設定と使用方法
