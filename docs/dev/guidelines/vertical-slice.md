# 縦切り実装戦略ガイド

このドキュメントは、`docs/ai/prompts/tasks/06_vertical_slice_implementation.md`（縦切り実装サイクル）における実装粒度の決定方法と、AI との相談プロトコルを定義します。

## 基本方針

### API 依存ステップのみバックエンド実装

- **フロントのみステップ**: 初期状態設定など、API 呼び出しを含まないステップ
- **API 依存ステップ**: バックエンド API を呼び出すステップ（フロント+バックエンド両方実装）

### 柔軟な実装粒度

実装粒度は状況に応じて選択：

1. **ステップ単位**: 最小差分、最速フィードバック
2. **API グループ単位**: 関連ステップをまとめて実装
3. **シナリオ単位**: 従来型の一括実装

## 実装粒度相談プロトコル

### AI の責務

各実装サイクル開始前に、AI は以下を分析・提案する：

#### 1. ステップ依存関係分析

各 Gherkin ステップについて：

- **API 依存**: 呼び出すエンドポイント（例: `POST /api/v1/photos`）
- **状態依存**: 前ステップの DB 状態に依存するか
- **フロントのみ**: API 不要で完結するか

**出力例（Mermaid 図）**:

```mermaid
graph TD
    A[Given: アプリアクセス] -->|フロントのみ| B[When: ボタンクリック]
    B -->|フロントのみ| C[And: ファイル選択]
    C -->|POST /photos| D[Then: アップロード成功]
    D -->|GET /photos/:id| E[And: プレビュー表示]
    E -->|フロントのみ| F[When: ダウンロードクリック]
    F -->|GET /photos/:id| G[Then: ダウンロード]

    style A fill:#e1f5e1
    style B fill:#e1f5e1
    style C fill:#e1f5e1
    style D fill:#ffe1e1
    style E fill:#ffe1e1
    style F fill:#e1f5e1
    style G fill:#ffe1e1
```

**凡例**:

- 🟢 緑: フロントのみ
- 🔴 赤: API 依存（バックエンド実装必要）

#### 2. 実装粒度提案

**作成ファイル**: `docs/plans/[機能仕様ファイル名]_[シナリオ識別子]_granularity.md`

以下を記載：

- **選択パターン**: A/B/C から最適なものを選択
- **選択理由**: なぜそのパターンを選んだか
- **実装グルーピング**: 具体的なグループ分け
- **実装上の注意点**: E2E 状態依存、Stub 判断、テストデータ準備方針

**3 つのパターン**:

| パターン | 粒度             | メリット                       | デメリット                     | 推奨度 |
| -------- | ---------------- | ------------------------------ | ------------------------------ | ------ |
| A        | ステップ単位     | 差分最小、素早いフィードバック | 状態分断リスク、頻繁な切り替え | ⭐⭐   |
| B        | API グループ単位 | 状態連続性確保、適度な粒度     | やや差分大きい                 | ⭐⭐⭐ |
| C        | シナリオ単位     | 従来型、手戻り少ない           | 差分大、フィードバック遅い     | ⭐     |

**通常はパターン B（API グループ単位）を推奨**:

- POST→GET など状態依存のあるステップをまとめて実装
- 1 サイクル 2-5 ステップ程度で適度な粒度
- E2E テストが自然な流れで実行できる

**主要な判断基準**:

- **E2E 状態依存**: POST→GET など DB 状態に依存する場合はグループ化
- **Stub 継続判断**: 他シナリオで再利用するか、実装の複雑さで判断
- **テストデータ準備**: グループ化すれば自然にデータが作成される

### 人間の責務

AI の提案を確認し、以下を決定：

1. **実装粒度の選択**: パターン A/B/C のいずれか
2. **調整指示**: 必要に応じてグルーピングをカスタマイズ
3. **実装開始承認**: 決定した粒度で実装サイクル開始

**決定例**:

```
「パターンBで進めてください。ただし、グループ2はステップ4-6まで含めてください」
```

## 実装サイクル詳細

### フロントのみステップ

```
1. Step Definition作成（e2e/step-definitions/）
   → Red確認
2. Unit Test作成（必要な場合）
   → Red確認
3. Implementation（src/frontend/）
   → Green確認
4. Refactor
5. E2E実行（バックエンドStub接続）
   → このステップまで通過確認
```

### API 依存ステップ（推奨フロー）

```
【ステージ1: フロント実装】
1. Step Definition作成
2. Unit Test作成
3. Implementation
4. E2E実行（バックエンドStub接続）
   → Green確認

【ステージ2: バックエンド実装】
6. ドメイン層TDD
   - Entity/ValueObject
   - Repository Interface + 実装
   - DomainService（必要な場合）
7. アプリケーション層TDD
   - UseCase
8. プレゼンテーション層TDD
   - Controller（Stub置き換え、TODOコメント削除）
   - DTO

【ステージ3: 統合確認】
9. E2E実行（実装済みバックエンド）
    → 該当ステップまで通過確認
10. レスポンス形式確認
    → OpenAPI仕様と完全一致を検証
```

## 状態管理の考慮事項

### 状態依存の種類

#### 1. DB 状態依存

前ステップで作成したリソースを後続ステップで使用：

```gherkin
When ユーザーが1枚目のJPEGファイルをアップロードする  # POST /photos → id: abc-123
Then 1枚目の画像がプレビューエリアに表示される        # GET /photos/abc-123
```

**対策**:

- API グループ単位でまとめて実装
- または `@BeforeEach` でテストデータ準備

#### 2. UI 状態依存

フロントエンドのステート（React State 等）に依存：

```gherkin
When ユーザーが「写真を選択」ボタンをクリックする
And ユーザーがファイルを選択する                   # State: selectedFile
Then プレビューエリアに選択した画像が表示される    # State: previewUrl
```

**対策**:

- フロントのみステップとしてまとめて実装
- Step Definition 内で state を引き継ぐ

#### 3. 独立ステップ

前後のステップと状態依存がない：

```gherkin
Given ユーザーがHatoMaskアプリケーションにアクセスしている
```

**対策**:

- 単独で実装可能
- ステップ単位実装でも問題なし

### 状態分断リスクの判定

AI が以下の基準で判定：

| 状態依存              | リスク | 推奨粒度                     |
| --------------------- | ------ | ---------------------------- |
| なし                  | 低     | ステップ単位可               |
| UI 状態のみ           | 低     | ステップ単位可（同一画面内） |
| DB 状態（同一 API）   | 中     | API グループ推奨             |
| DB 状態（異なる API） | 高     | API グループ必須             |

## 実装粒度決定のフローチャート

```mermaid
graph TD
    Start[実装サイクル開始] --> Analyze[AIがステップ依存関係分析]
    Analyze --> Propose[AIが3パターン提案]
    Propose --> Check{状態依存あり?}

    Check -->|なし| Small[パターンA推奨<br/>ステップ単位]
    Check -->|あり| CheckType{依存タイプは?}

    CheckType -->|UI状態のみ| Small
    CheckType -->|DB状態| Medium[パターンB推奨<br/>APIグループ単位]
    CheckType -->|複雑な依存| Large[パターンC検討<br/>シナリオ単位]

    Small --> Consult[人間が確認・決定]
    Medium --> Consult
    Large --> Consult

    Consult --> Execute[実装サイクル実行]
    Execute --> Next{次のグループあり?}

    Next -->|あり| Analyze
   Next -->|なし| End[縦切り実装サイクル完了]
```

## 実装例

### シナリオ: JPEG ファイルのアップロードとダウンロード

```gherkin
Given ユーザーがHatoMaskアプリケーションにアクセスしている
When ユーザーが「写真を選択」ボタンをクリックする
And ユーザーがファイルサイズ5MBのJPEGファイルを選択する
Then アップロードが成功する
And プレビューエリアに選択した画像が表示される
When ユーザーが「ダウンロード」ボタンをクリックする
Then 元の画像がダウンロードされる
```

### AI の分析結果

**依存関係**:

```
ステップ1 (Given): フロントのみ
ステップ2 (When): フロントのみ
ステップ3 (And): フロントのみ
ステップ4 (Then): POST /api/v1/photos → DB状態作成
ステップ5 (And): GET /api/v1/photos/:id → ステップ4のDB状態依存
ステップ6 (When): フロントのみ
ステップ7 (Then): GET /api/v1/photos/:id → ステップ4のDB状態依存
```

**提案**:

| パターン | グルーピング                  | 推奨度 |
| -------- | ----------------------------- | ------ |
| A        | 1, 2, 3, 4, 5, 6, 7（各個別） | ⭐     |
| B        | [1-3], [4-5], [6-7]           | ⭐⭐⭐ |
| C        | [1-7]                         | ⭐⭐   |

**推奨: パターン B**

**理由**:

- ステップ 4 で POST、ステップ 5 で GET するため、連続実装が効率的
- ステップ 6-7 も同様に GET 依存があるが、既に POST 実装済みなので分離可能

### 実装スケジュール（パターン B 採用）

**サイクル 1: フロントのみ（ステップ 1-3）**

```
1. Step Definition: Given, When, And
2. Implementation: App初期表示、ボタン、ファイル選択UI
3. E2E確認（バックエンドStub不要）
```

**サイクル 2: アップロード〜プレビュー（ステップ 4-5）**

```
フロント:
1. Step Definition: Then (アップロード成功), And (プレビュー)
2. Implementation: アップロード処理、プレビュー表示

バックエンド:
4. Domain: Photo Entity, PhotoRepository
5. UseCase: UploadPhotoUseCase, GetPhotoUseCase
6. Controller: POST /photos, GET /photos/:id（Stub置き換え）

統合:
7. E2E実行（実装済みバックエンド、ステップ1-5通過確認）
```

**サイクル 3: ダウンロード（ステップ 6-7）**

```
フロント:
1. Step Definition: When (ダウンロードクリック), Then (ダウンロード)
2. Implementation: ダウンロード処理

バックエンド:
3. UseCase: DownloadPhotoUseCase（GetPhotoを再利用）
4. Controller: レスポンスヘッダー調整

統合:
5. E2E実行（ステップ1-7全通過確認）
```

## まとめ

### 縦切り実装の成功ポイント

1. **API Contract 確立（Task03）**: OpenAPI 仕様が明確であること
2. **依存関係分析（Task04）**: 事前にグルーピング案を準備
3. **Stub 品質（Task05）**: バックエンド Stub が OpenAPI に忠実
4. **粒度相談（Task06）**: 状況に応じた柔軟な粒度選択
5. **継続的な統合確認**: 各サイクル完了時に E2E 実行

### 推奨デフォルト

特に理由がなければ**パターン B（API グループ単位）**を選択。
状態依存が少ない場合はパターン A（ステップ単位）も検討。
