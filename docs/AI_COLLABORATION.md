# AI 協働開発手法

このドキュメントでは、HatoMask App プロジェクトにおける**AI 協働開発の思想、原則、プロセス**を解説します。

## 目次

- [思想（Philosophy）](#思想philosophy)
- [原則（Principles）](#原則principles)
- [開発プロセス（Process）](#開発プロセスprocess)
- [実践（Practice）](#実践practice)

---

## 思想（Philosophy）

### AI を開発プロセスの協働パートナーとして位置づける

このプロジェクトでは、AI を単なる「コード生成ツール」として扱うのではなく、**構造化された開発プロセスの一部**として統合しています。

#### 1. ドキュメント駆動 × AI 協働

**何をするか**:

仕様書 → ドメインモデル →API 仕様 → 実装という順序で、段階的にドキュメントを作成しながら開発を進めます。

```
Spec → ドメインモデル → API Contract → 実装計画 → 実装 → テスト → 統合
```

AI には以下の 2 種類のプロンプトで知識を共有します：

- **システムプロンプト**: プロジェクトの共通ルール（役割、ワークフロー、品質基準）
- **タスクプロンプト**: 各作業の具体的な手順（テンプレート化された Phase 1-7 の手順）

**メリット**:

- **手戻りが少ない**: 仕様が明確になってから実装するため、認識齟齬による修正が減る
- **効率的な協働**: AI に毎回同じ説明をする必要がなく、プロンプトで一貫した品質を維持
- **理解しやすい**: 開発の過程がドキュメントとして記録されるため、後から参加するメンバーもキャッチアップしやすい
- **同期が取れる**: 実装前に仕様を確定し、実装後にテストで検証することで、ドキュメントとコードの乖離を防止

#### 2. 段階的アプローチ（1 ステップずつ確実に）

**何をするか**:

「1 ステップ 1 プロンプト」の原則に従い、AI には一度に 1 つのことだけを依頼します。AI に全体を投げず、現在実装すべき 1 ステップのみを指示します。

テスト駆動開発（TDD）の以下のサイクルを厳守します：

- **Red（失敗）**: まずテストを書き、失敗することを確認
- **Green（成功）**: 最小限の実装でテストを通す
- **Refactor（改善）**: コードを整理し、品質を向上

**制約**:

- **先読み実装の禁止**: AI が勝手に後続ステップを実装することを明示的に禁止
- **各ステップでの確認**: Red/Green を確認してから次へ進む

**メリット**:

- **問題の特定が容易**: 問題が起きてもどこで発生したか特定しやすい
- **AI の暴走防止**: AI が勝手に先回りして余計なコードを書くことを防げる
- **品質の確保**: 小さな成功を積み重ねることで、着実に品質を確保できる
- **早期フィードバック**: 各ステップで動作確認し、問題を早期発見

#### 3. 縦切り開発（小さな単位で完結させる）

**何をするか**:

「フロントエンドを全部作ってからバックエンド」という水平分割ではなく、小さな実装単位で UI→API→ ビジネスロジック → データベースまで一気通貫で動くようにしてから、次の単位に進みます。

**実装の進め方**:

- **小さな単位**: 例えば「ログインボタンを押す」という 1 つの操作レベル
- **一気通貫**: その操作に必要なフロント → バック →DB までを 1 セットで実装
- **API Contract First**: OpenAPI 仕様を中立な契約として先に確立し、フロント/バックの齟齬を防止
- **柔軟な実装粒度**: ステップ単位/API グループ単位/シナリオ単位を AI が分析し、人間が決定

**メリット**:

- **早期の動作確認**: 小さく動くものを積み重ねるため、早い段階で動作確認できる
- **連携ミスの早期発見**: フロントとバックの連携ミスを早期に発見できる
- **影響範囲の最小化**: 問題が起きても影響範囲が小さいので、修正しやすい
- **価値の早期提供**: 各スライスが独立して動作可能な機能を提供

---

## 原則（Principles）

### AI 制御のための設計原則

#### 1. 明示的な制約

AI の「暴走」を防ぐため、以下の制約を明示的に設定しています：

- **先読み実装の禁止**: 指示されていないステップを実装しない
- **1 プロンプト 1 ステップ**: 複数のステップを同時に指示しない
- **テストファースト**: 実装前に必ずテストを書く
- **規約遵守**: コーディング規約を自己チェックし、違反を防止

#### 2. 思考プロセスの明示化

複雑な判断が必要な場合、AI は以下の形式で思考を共有します：

```markdown
### 検討事項

- 考慮すべきポイント 1
- 考慮すべきポイント 2

### 選択肢

1. 選択肢 A: メリット・デメリット
2. 選択肢 B: メリット・デメリット

### 推奨

選択肢 A を推奨。理由：...
```

#### 3. 人間と AI の役割分担

| 役割           | 人間                                           | AI                                           |
| -------------- | ---------------------------------------------- | -------------------------------------------- |
| **意思決定**   | 実装粒度の選択、リスク判断、アーキテクチャ決定 | -                                            |
| **分析・提案** | -                                              | 依存関係分析、実装計画策定、テストケース生成 |
| **実装**       | レビュー、承認                                 | コード生成、テスト実装                       |
| **検証**       | 最終確認、受け入れテスト                       | ユニットテスト、静的解析                     |

---

## 開発プロセス（Process）

### 7 段階の開発フロー

このプロジェクトでは、以下の 7 つの Phase で開発を進めます。

```mermaid
graph LR
    A[Phase 1: Spec作成] --> B[Phase 2: ドメインモデリング]
    B --> C[Phase 3: API Contract設計]
    C --> D[Phase 4: Gherkinシナリオ<br/>+ 実装計画策定]
    D --> E[Phase 5: Backend Stub生成]
    E --> F[Phase 6: 縦切り実装サイクル]
    F --> G[Phase 7: 統合テスト]
```

#### Phase 1: Spec 作成（要件定義）

- **目的**: 機能の受け入れ基準を明確化
- **成果物**: `docs/spec/features/XX_feature_name.md`
- **記述形式**: Given-When-Then 形式（BDD）

#### Phase 2: ドメインモデリング（初稿）

- **目的**: ビジネスロジックの概念を整理
- **成果物**: `docs/spec/models/XX_domain_model.md`
- **内容**: Entity, ValueObject, Repository Interface
- **AI タスク**: `docs/ai/prompts/tasks/02_simple_modeling.md`

#### Phase 3: API Contract 設計 + モデル見直し

- **目的**: フロント/バック間の契約を確立
- **成果物**: `docs/spec/api/XX_api_name.yaml`（OpenAPI 仕様）
- **特徴**: Phase 2 で作成したドメインモデルを見直し、1 往復で概念を揃える
- **AI タスク**: `docs/ai/prompts/tasks/03_design_api_contract.md`

#### Phase 4: Gherkin シナリオ + 実装計画策定

- **目的**: E2E テストシナリオと実装計画を作成
- **成果物**:
  - `e2e/features/XX_feature_name.feature`（Gherkin シナリオ）
  - `docs/plans/[Spec名]_[シナリオ識別子].md`(実装計画)
- **実装計画の内容**:
  - 各 Gherkin ステップの実装分類（API 依存/状態依存/フロントのみ）
  - 推奨グルーピング（API グループ単位の提案）
  - ステップ間の依存関係分析（Mermaid 図）
- **AI タスク**: `docs/ai/prompts/tasks/01_create_feature_spec.md`, `04_plan_implementation.md`

#### Phase 5: Backend Stub 生成

- **目的**: フロント実装前にバックエンドに固定データを返す Stub を生成
- **成果物**: `src/backend/src/main/java/.../StubController.java`
- **利点**: フロントが早期に統合テスト可能、API Contract の検証が容易
- **AI タスク**: `docs/ai/prompts/tasks/05_generate_stubs.md`

#### Phase 6: 縦切り実装サイクル

**Outside-In TDD（E2E → Frontend → Backend）** を採用し、1 機能単位で UI→API→ ドメイン →DB まで貫通します。

```mermaid
graph TD
    A[E2Eテスト実行<br/>Red] --> B[Frontendステップ実装<br/>Green]
    B --> C[Backendテストリスト作成]
    C --> D[Backend TDD実装<br/>Red-Green-Refactor]
    D --> E[E2Eテスト実行<br/>Green]
    E --> F{次のステップへ}
```

**サブサイクル**:

1. **E2E テスト実行（Red）**: Gherkin シナリオを実行し、失敗を確認
2. **Frontend ステップ実装（Green）**: UI/API 呼び出しを実装（Stub に接続）
3. **Backend テストリスト作成**: ドメイン層/API 層のテストケースを計画
4. **Backend TDD 実装（Red-Green-Refactor）**:
   - ドメイン層: Entity → Repository → UseCase
   - API 層: Controller（Stub を本実装に置き換え）
5. **E2E テスト実行（Green）**: 実装完了を確認

**AI タスク**: `docs/ai/prompts/tasks/06_vertical_slice_implementation.md`

#### Phase 7: 統合テスト

- **目的**: 全機能の統合動作を確認
- **実行内容**: E2E テストスイート全体の実行、パフォーマンステスト、セキュリティテスト

---

## 実践（Practice）

### AI 制御のプロトコル

#### 1. 実装粒度の相談プロトコル

AI は実装開始前に、以下の 3 パターンを提案します：

| パターン                     | 粒度     | メリット                               | デメリット                         |
| ---------------------------- | -------- | -------------------------------------- | ---------------------------------- |
| **ステップ単位**             | 最小差分 | 問題の早期発見、Red-Green 高速サイクル | 実装回数が多く、時間がかかる       |
| **API グループ単位**（推奨） | 中程度   | バランスが良い、API 境界で自然に分割   | 依存関係の把握が必要               |
| **シナリオ単位**             | 大規模   | 実装回数が少ない                       | 問題の発見が遅れる、Red 期間が長い |

**決定**: 人間が選択（通常は API グループ単位を推奨）

#### 2. テストリスト駆動 TDD

実装前にテストケースを Markdown ファイルで計画します：

**例**: `docs/plans/01_photo_upload_domain_testlist.md`

```markdown
# Photo Upload ドメイン層 テストリスト

## Entity: Photo

- [ ] 正常系: 有効なファイル名と MIME タイプで Photo エンティティを作成できる
- [ ] 異常系: ファイル名が null の場合、IllegalArgumentException をスローする
- [ ] 異常系: サポートされていない MIME タイプの場合、例外をスローする

## Repository: PhotoRepository

- [ ] 正常系: Photo エンティティを保存できる
- [ ] 正常系: ID で Photo エンティティを取得できる
- [ ] 異常系: 存在しない ID で取得すると、空の Optional を返す
```

**カバレッジ目標**:

- 全体: 80%以上
- 重要ロジック: 90%以上
- ユーティリティ: 100%

#### 3. Backend Stub 戦略

**Stub の役割**:

- OpenAPI 仕様と完全一致するレスポンスを返す
- フロント実装時に実際のバックエンドとして機能
- API 依存ステップの実装時に本実装に段階的に置き換え

**例**:

```java
@RestController
@RequestMapping("/api/v1/photos")
public class PhotoStubController {

    @PostMapping(consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<ApiResponse<PhotoUploadResponse>> uploadPhoto(
            @RequestParam("file") MultipartFile file) {
        // Stub: 固定データを返す
        PhotoUploadResponse response = new PhotoUploadResponse(
            "stub-photo-id-12345",
            "example.jpg",
            Instant.now()
        );
        return ResponseEntity.ok(ApiResponse.success(response));
    }
}
```

#### 4. 依存関係分析

AI は各 Gherkin ステップの依存関係を以下のように分類します：

```markdown
| ステップ                                    | 分類         | API 依存            | 状態依存         | 備考                 |
| ------------------------------------------- | ------------ | ------------------- | ---------------- | -------------------- |
| Given ユーザーがトップページにアクセスする  | フロントのみ | なし                | なし             | ルーティングのみ     |
| When ユーザーが写真をアップロードする       | API 依存     | POST /api/v1/photos | なし             | バックエンド実装必要 |
| Then アップロード成功メッセージが表示される | 状態依存     | なし                | 前ステップの結果 | フロント状態管理     |
```

**Mermaid 図による可視化**:

```mermaid
graph LR
    A[Given: トップページ] --> B[When: 写真アップロード]
    B --> C[Then: 成功メッセージ]
    B -.API依存.-> D[POST /api/v1/photos]
```

---

## まとめ

HatoMask App プロジェクトの AI 協働開発は、以下の特徴を持ちます：

1. **ドキュメント駆動**: 仕様 → モデル →API→ 実装の段階的進化
2. **段階的アプローチ**: 1 ステップ 1 プロンプト、Red-Green-Refactor、先読み実装禁止
3. **縦切り開発**: 1 機能単位で UI→API→ ドメイン →DB まで貫通
4. **明示的な制約**: AI の暴走を防ぐプロトコル設計
5. **人間と AI の役割分担**: 意思決定は人間、分析・実装は AI

このアプローチにより、AI との協働で**再現可能**かつ**高品質**なソフトウェア開発を実現しています。

---

## 関連ドキュメント

- [開発ガイド](./dev/DEVELOPMENT.md) - TDD 開発フロー、テスト実行方法
- [コーディング規約](./dev/CODING_STANDARDS.md) - 命名規則、設計原則
- [品質基準](./dev/QUALITY_STANDARDS.md) - 品質基準とベストプラクティス
- [AI プロンプト集](./ai/prompts/tasks/) - タスク別指示テンプレート
- [システムプロンプト](./ai/prompts/system/) - AI の基本動作定義
